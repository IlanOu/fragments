using UnityEngine;
using NPC.NPCAnimations;

class NPCMovementLookAtTarget : NPCMovementStrategy
{
    private readonly GameObject target;
    private readonly float holdDuration;

    private float timer;
    private bool launched;

    public NPCMovementLookAtTarget(NPCMovement mov,
                                  GameObject target,
                                  float duration)
        : base(mov)
    {
        this.target = target;
        this.holdDuration = Mathf.Max(0f, duration);

        if (target == null)
        {
            mov.Enabled = false;
            Debug.LogError("LookAtTarget : target manquant !");
        }
        else
        {
            // Debug pour vérifier que la cible est bien référencée
            Debug.Log($"LookAtTarget initialisé avec cible: {target.name} à position {target.transform.position}");
        }
    }

    public override void StartMovement()
    {
        if (launched || target == null) return;
        launched = true;
        timer = 0f;
    
        // On désactive la rotation automatique du NavMeshAgent
        MainAgent.updateRotation = false;
        
        // Désactiver Root Motion pendant le regard
        Animator animator = npcMovement.Manager.GetComponentInChildren<Animator>();
        if (animator != null)
        {
            animator.applyRootMotion = false;
        }
    
        // On coupe l'anim Walk au cas où
        NPCAnimBus.Bool(npcMovement.Manager.gameObject,
                        NPCAnimationsType.Walk, false);
    }

    public override bool IsDone
    {
        get
        {
            if (!launched || target == null) return false;

            Rotate();

            timer += Time.deltaTime;
            bool finished = timer >= holdDuration;

            if (finished)
            {
                MainAgent.updateRotation = true;   // on rend la main à l'agent
            
                // Réactiver Root Motion à la fin si nécessaire
                Animator animator = npcMovement.Manager.GetComponentInChildren<Animator>();
                if (animator != null)
                {
                    animator.applyRootMotion = true;
                }
            }

            return finished;
        }
    }

    private void Rotate()
    {
        // Transform du personnage
        Transform me = npcMovement.Manager.transform;

        // Afficher les positions pour debug
        Debug.DrawLine(me.position, target.transform.position, Color.red);
        
        // Direction vers la cible
        Vector3 dir = target.transform.position - me.position;
        
        // Log pour debug
        if (Time.frameCount % 60 == 0) // Log toutes les ~1 seconde
        {
            Debug.Log($"Position NPC: {me.position}, Position cible: {target.transform.position}");
            Debug.Log($"Direction calculée: {dir}, magnitude: {dir.magnitude}");
            Debug.Log($"Rotation actuelle: {me.rotation.eulerAngles}");
        }
        
        // Si la cible est trop proche, on évite la rotation bizarre
        if (dir.sqrMagnitude < 0.001f) return;

        // Utilisons directement Transform.LookAt qui est plus fiable
        Vector3 targetPosition = target.transform.position;
        
        // Créons une position cible à la même hauteur que le NPC pour éviter l'inclinaison
        Vector3 lookPosition = new Vector3(targetPosition.x, me.position.y, targetPosition.z);
        
        // Utiliser LookAt directement
        me.LookAt(lookPosition);
        
        // Log la rotation finale
        if (Time.frameCount % 60 == 0)
        {
            Debug.Log($"Rotation après LookAt: {me.rotation.eulerAngles}");
        }
    }
}
